from geometry_msgs.msg import Quaternion
import numpy as np
from numpy.typing import NDArray

def rotmat2q(T: NDArray) -> Quaternion:
    # Function that transforms a 3x3 rotation matrix to a ROS quaternion representation
    if T.shape != (3, 3):
        raise ValueError("Input matrix must be of shape (3, 3).")

    # Ensure the matrix is valid (orthogonal and determinant = 1)
    if not np.allclose(np.dot(T, T.T), np.eye(3)) or not np.isclose(np.linalg.det(T), 1.0):
        raise ValueError("Input matrix is not a valid rotation matrix.")

    trace = np.trace(T)

    if trace > 0:
        S = 2.0 * np.sqrt(trace + 1.0)
        w = 0.25 * S
        x = (T[2, 1] - T[1, 2]) / S
        y = (T[0, 2] - T[2, 0]) / S
        z = (T[1, 0] - T[0, 1]) / S
    elif (T[0, 0] > T[1, 1]) and (T[0, 0] > T[2, 2]):
        S = 2.0 * np.sqrt(1.0 + T[0, 0] - T[1, 1] - T[2, 2])
        w = (T[2, 1] - T[1, 2]) / S
        x = 0.25 * S
        y = (T[0, 1] + T[1, 0]) / S
        z = (T[0, 2] + T[2, 0]) / S
    elif T[1, 1] > T[2, 2]:
        S = 2.0 * np.sqrt(1.0 + T[1, 1] - T[0, 0] - T[2, 2])
        w = (T[0, 2] - T[2, 0]) / S
        x = (T[0, 1] + T[1, 0]) / S
        y = 0.25 * S
        z = (T[1, 2] + T[2, 1]) / S
    else:
        S = 2.0 * np.sqrt(1.0 + T[2, 2] - T[0, 0] - T[1, 1])
        w = (T[1, 0] - T[0, 1]) / S
        x = (T[0, 2] + T[2, 0]) / S
        y = (T[1, 2] + T[2, 1]) / S
        z = 0.25 * S

    # Return the quaternion as a ROS geometry_msgs.msg.Quaternion object
    q = Quaternion()
    q.x = x
    q.y = y
    q.z = z
    q.w = w

    return q
